<!-- .slide: data-background="../content/images/title-slide.jpg" -->

## Building Applications with Angular

# Unit Testing

---

## Roadmap

1. What tools should I use to test Angular applications?
1. Where should I put my tests?
1. How can I write and run simple tests?
1. How can I run the tests generated by Angular CLI?
1. How can I create mock objects for dependencies?
1. How can I simulate application changes?
1. How can I query native HTML elements?
1. How can I test asynchronous behaviors?

---

## Toolchain

- [Jasmine](https://jasmine.github.io/): behavior-driven testing framework
- [Karma](https://karma-runner.github.io/1.0/index.html): test runner
- [Istanbul](https://gotwarlost.github.io/istanbul/): coverage report generator

---

## Running Tests

- `ng test`: lauches a browser for testing and watches for changes.
  - Compiles and re-runs tests as files change
- `ng test --code-coverage`: puts a coverage report in `coverage/` directory

---

## Creating Test Files

- Angular CLI automatically creates test files for components
- Adds `.spec` to test file names so Jasmine and the build system recognize them as tests
- E.g., `src/app/app.component.spec.ts` does basic tests of `AppComponent`

---

## Arrange, Act and Assert with Jasmine

Note the following in the generated tests:

- `describe` explains what the test is
- `beforeEach` runs code before each test
- `it` explains the result we are expecting
- `expect` formulates a scenario
- `toBeTruthy` is a matcher that asserts the expected outcome

---

## Testing a Pipe

- `ng generate pipe pipe capitalize`

#####_src/app/capitalize.pipe.ts_
```ts
import { Pipe, PipeTransform } from '@angular/core';
@Pipe({
  name: 'capitalize'
})
export class CapitalizePipe implements PipeTransform {
  transform(inputText: string, args?: any): string {
    return inputText.charAt(0).toUpperCase() + inputText.slice(1);
  }
}
```

---

## Starter Code for Testing

#####_src/app/capitalize.pipe.spec.ts_
```ts
import { CapitalizePipe } from './capitalize.pipe';

describe('CapitalizePipe', () => {
  it('create an instance', () => {
    const pipe = new CapitalizePipe();
    expect(pipe).toBeTruthy();
  });
});
```

---

## Instantiate the Fixture in `beforeEach`

- We will need a fixture for each test, so don't duplicate that code

#####_src/app/capitalize.pipe.spec.ts_
```ts
describe('CapitalizePipe', () => {

  let pipe;
  
  beforeEach(() => {
    pipe = new CapitalizePipe();
  });

  …instance creation test as before…

}
```

- Have to declare `pipe` outside `beforeEach` so that it will be visible in test functions

---

## Add a Test

#####_src/app/capitalize.pipe.spec.ts_
```ts
describe('CapitalizePipe', () => {

  …as before…

  it('should capitalize a word', () => {
    expect(pipe.transform('foo')).toEqual('Foo');
  });
}
```

---

## Getting Tests to Run

- Run `ng test`: 4 failures
- Have to include our dependencies in `app.component.spec.ts`
  - And in `to-do-list.component.spec.ts`

#####_src/app/app.component.spec.ts_
```ts
    TestBed.configureTestingModule({
      declarations: [
        AppComponent,
        ToDoListComponent,
        GenericInputComponent
      ],
      providers: [
        ToDoService
      ]
    }).compileComponents();
```

---

## Cleaning Up Technical Debt

- Title is now "To Do" instead of "app works!"
- Notice we're no longer passing data to the display in `thingsToDo`,
  so remove it from the HTML and erase the `@Input`

![Auto-Generated Tests Running](content/images/screenshot-jasmine-defaults-run.png)

---

## Instantiating the Component or Service

- How would we test `itemCount` on `AppComponent`?

#####_src/app/app.component.ts_
```ts
export class AppComponent {
  …as before…
  itemCount() {
    return this.toDoService.itemCount();
  }
}
```

#####_src/app/to-do.service.ts_
```ts
export class ToDoService {
  …as before…
  itemCount() {
    return this.items.length;
  }
}
```

---

## Mocking Dependencies

- We need an object that matches the "shape" of `TodoService` to test `AppComponent`
- The mock object must have `onNewItem` and `itemCount` methods
- `onNewItem` doesn't actually need to do anything
- `itemCount` can return a fixed value

```ts
mockTodoService = {
  onNewItem: (item: string) => {}
  itemCount: () => 3
};
```

- We can inject this into `AppComponent` by passing it to the constructor
  - Which is one of the reasons Angular uses this technique for dependency injection

---

## Testing Business Logic

#####_src/app/app.component.spec.ts_
```ts
  describe('the itemCount method', () => {

    let app: AppComponent;
    let mockToDoService;

    beforeEach(() => {
      mockToDoService = {
        onNewItem: (item: string) => {}
        itemCount: () => 3
      };
      app = new AppComponent(mockToDoService);
    });

    it('should return the number of items', () => {
      expect(app.itemCount()).toEqual(3);
    });
  });
```

<!-- preview: http://plnkr.co/edit/XUM8Gfz08nfbQf1BhDN1?p=preview FIXME update -->

---

## When to Use TestBed

`TestBed` is helpful when:

1. you have logic in your templates and you want to render a component class along with its template for testing
2. you want to use Angular's injector to handle dependecy injection for you
3. you want to test how different elements integrate in the Angular runtime

<!-- comment needed to separate lists -->

- We do not instantiate the class we want to test when using `TestBed`
  - We let Angular do that for us
- Using the test fixture, Angular will give us the instance it created

---

## Providing Mock Dependencies

- We can declare `mockTodoService` as we did before and have Angular inject it for us

#####_src/app/app.component.spec.ts_
```ts
TestBed.configureTestingModule({
  declarations: [ mockTodoService ]
  providers:[
    { provide: TodoService, useValue: mockTodoService }
  ]
})
```

---

## Spying on Real Service Providers

- Alternatively, we can have Angular create the real service
- And mock specific methods through a Jasmine *spy*
  - The spy will ensure we don't actually call the real method
- Always obtain injected dependencies from `TestBed`
  so that the spy is set on the instance that is injected and not the object we created

#####_src/app/app.component.spec.ts_
```ts
TestBed.configureTestingModule({
  declarations: [ AppComponent ]
  providers:[ TodoService ]
});

const todoService = TestBed.get(TodoService);
spyOn(todoService, 'itemCount').and.callFake(() => 3);
```

<!--
FIXME: check the example above
1. Do we still call `compileComponents` on `TestBed`?
2. Is the syntax right for `callFake`?
-->

---

## Importing Real Application Modules

- We can import a real module that declares the component and provides the service it depends on

```ts
TestBed.configureTestingModule({
  imports: [ AppModule ]
})
```

- Inject actual services or importing real modules often works…
- …but sometimes Angular is not able to resolve all of the required dependencies
- We have more control when we mock things…
- …but if mocks get too complicated, they can be expensive to maintain

---

## Testing Components Using ComponentFixture

Here is how we obtain the instance from the fixture:

#####_src/app/app.component.spec.ts_
```ts
let fixture: ComponentFixture<AppComponent>;
let comp: AppComponent;

beforeEach(() => {
  TestBed.configureTestingModule({
    declarations: [ AppComponent ],
    providers: [
      { provide: TodoService, useValue: mockTodoService }
    ]
  });

  fixture = TestBed.createComponent(AppComponent);
  comp = fixture.componentInstance;
});
```

---

## Change Detection

- We must tell Angular when to run change detection during our tests
- Use the fixture to do this:

#####_src/app/app.component.spec.ts_
```ts
fixture = TestBed.createComponent(AppComponent);
fixture.detectChanges()
```

---

## Change Detection

- Can indicate that we want *automatic change detection* when configuring our test module

#####_src/app/app.component.spec.ts_
```ts
TestBed.configureTestingModule({
  declarations: [ ],
  providers: [
    { provide: ComponentFixtureAutoDetect, useValue: true }
  ]
});
```

---

## Querying Native Elements

- Once change detection has run, we can check that the expeced output was rendered to the DOM

#####_src/app/app.component.spec.ts_
```ts
describe('AppComponent', () => {
  let comp: AppComponent;
  let fixture: ComponentFixture<AppComponent>;

  beforeEach(() => {
    // TestBed.configureModule({ ...
    fixture = TestBed.createComponent(AppComponent);
    comp = fixture.componentInstance;
  });

  it('should show the number of items', () => {
    const de = fixture.debugElement.query(By.css('.qa-todo-count'));
    const el = fixture.nativeElement;
    fixture.detectChanges();
    expect(el.textContent).toContain('3 item(s)');
  });
});
```

---

## Dealing With Asynchronous Behavior in Tests

- Angular CLI uses the asynchronous function `compileComponents` and wraps it in the `async` function
- `compileComponents` is required for testing when classes reference external files through `templateUrls` and `styleUrls`.
- We usually don't need to do this
  - Webpack will inline our templates and css as part of the build process
  - But we will often need to use `async` and a similar function `fakeAsync` in our tests

---

## Running Tests in a Zone

- Jasmine can run asynchronous tests like this:

```ts
it('should...', (done) => {
  myComponent.getData().subscribe(data => {
    expect(data).toEqual({abc: 123});
    done();
  });
});
```

- Without `done` the test finishes before the callback is run
- Angular's solution is to run all of our test code inside a [Zone.js](https://github.com/angular/zone.js) zone
  where it can track all asynchronous activity and wait for all tasks to complete

---

## Interlude: Zone.js

- Zones allow Angular to create execution contexts that track the completion of ansynchronous operations
- [Zone.js](https://github.com/angular/zone.js) accomplishes this by monkey patching many common asynchronous methods
- Zones are used in Angular applications to let Angular know when change detection should run
  - Since change detection is often required after asynchronous operations complete

---

## Using `async`

- The same test could be written as:

```ts
it('should...', async(() => {
  myComponent.getData().subscribe(data => {
    expect(data).toEqual({abc: 123});
  });
}));
```

- Angular will now wait for the `expect` function to complete

---

## Using `fakeAsync`

- This test tests debouncing *without* actually waiting for hundreds of milliseconds
  - Assumes `comp` has been assigned a component to test

```ts
it('should debounce change to search query for 300 ms', fakeAsync(() => {
  spyOn(comp.queryChanged, 'emit');
  comp.onChange('abc');
  tick(100);
  expect(comp.queryChanged.emit).not.toHaveBeenCalled();
  tick(200);
  expect(comp.queryChanged.emit).toHaveBeenCalledWith('abc');
}));
```

---

## Testing Services

- Test services in Angular using many of the same techniques and strategies used for testing components
- Main emphasis in testing services is data
  - Are we *getting*, *storing*, and *propagating* data correctly?
- Services will typically make HTTPS requests, so we will want to:
  - Verify the contents of the request being made (correct URL)
  - Ensure that the data we mock is returned by the right method
  - Ensure that data is being returned in the correct format

---

##  Mocking Angular’s Http Service

- Suppose we want to test a version of `TodoService` that uses `Http`'s `get` method

```ts
export class TodoService {
  public todoList = [];
  constructor(private http: Http) {}
  getTodoList() {
    return this.http.get('http://localhost:3000/todos')
      .map(response => response.json())
      .map(item => item.map(todo => this.getTodoTaskForDisplay(todo.label, todo.done, todo.id)))
      .subscribe(todos => this.todoList = todos);
  }
  getTodoTaskForDisplay(label, isComplete, id) {
    return {
      id,
      label,
      isComplete
    };
  }
}
```

---

## Creating and Injecting the Mock Object

- The backend returns data that looks like this:

```json
{
  "todos": [
    {
      "done": true,
      "id": 1,
      "label": "Wake up in the morning"
    },
    {
      "done": true,
      "id": 2,
      "label": "Grab glasses, go out the door, hit the city"
    }
  ]
}
```

---

## Creating and Injecting the Mock Object

- We can create a light mock of the `Http` service:

```ts
beforeEach(() => {
  mockHttp = { get: () => { } };

});
```

---

## Creating and Injecting the Mock Object

- We then create a spy for its `get` method
- Return an observable similar to what the real `Http` service would
- Then instantiate the service

```ts
  spyOn(mockHttp, 'get').and.returnValue(Observable.of({
    json: () => [
      { 'done': false, 'id': 1, 'label': 'item 1' },
      { 'done': true, 'id': 2, 'label': 'item 2' }
    ]
  }));

  todoService = new TodoService(mockHttp);
});
```

---

## Asserting on the Request and Response

- This method still allows us to check that the service
  - Has requested the right URL
  - Returns that expected data

```ts
it('should have the list of todos', () => {
  todoService.getTodoList();
  expect(todoService.todoList.length).toBe(2);
});
```

<!-- preview: http://plnkr.co/edit/eplM1SETfR51USVZLUlU?p=preview FIXME: update this -->

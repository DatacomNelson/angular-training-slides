<!-- .slide: data-background="../content/images/title-slide.jpg" -->

## Building Applications with Angular

# Services

---

## Roadmap

1. What is a service?
1. How do we create services?
1. How do we use services?
1. Why do we use services?

---

## What is a Service?

- Something that provides functionality to many components
  - Frequently implemented as a singleton
  - Database connection, HTTP, etc.
- Does not produce a view itself

---

## Creating a Service

- Use `ng generate service toDo`
- Creates `src/app/to-do.service.*`
  - Note: in the `src/app` directory
  - We could (and should) create a `services` directory

```
├── src
│   ├── app
│   │   ├── to-do.service.spec.ts
│   │   └── to-do.service.ts
```

---

## What's in a Service?

- A service is just a class decorated with `@Injectable`

_src/app/to-do.service.ts_
```ts
import { Injectable } from '@angular/core';

@Injectable()
export class ToDoService {

  constructor() { }

}
```

---

## Registering a Service

- Services need to be registered before they can be used
  - Angular CLI does this automatically for new components
- Must add the class name to the `providers` field in `src/app/app.module.ts`
- Which means importing the class name from `./to-do.service`
  - Note: must have `./` at the start of the path
  - And must *not* include the `.ts` suffix

---

## Registering a Service

_src/app/app.module.ts_
```ts
…other imports generated by Angular CLI…
import { ToDoService } from './to-do.service';

@NgModule({
  declarations: [
    AppComponent,
    ToDoListComponent,
    GenericInputComponent
  ],
  imports: [
    BrowserModule,
    FormsModule,
    HttpModule
  ],
  providers: [
    ToDoService     // added
  ],
  bootstrap: [AppComponent]
})
```

---

## Getting Access to a Service

- Define a `private` constructor variable of the appropriate type
- Angular's *dependency injection* system creates an instance variable with that name

_src/app/to-do-list/to-do-list.component.ts_
```ts
…other imports as before…
import { ToDoService } from '../to-do.service';

@Component({
  …as before…
})
export class ToDoListComponent implements OnInit {

  @Input() thingsToDo: string[];

  constructor(private toDoService: ToDoService) { }

  ngOnInit() {
  }
}
```

---

## A Plan for Refactoring

1. `GenericInputComponent` gets a new item and sends it to `AppComponent`
   - No change required
1. `AppComponent` gives it to `ToDoService`
   - Inject `ToDoService` into `AppComponent`
   - Remove `thingsToDo` from `AppComponent`, since it is no longer storing state
1. `ToDoService` stores the current list of items
1. `ToDoListComponent` watches the service for new lists of items
   - Send it the entire new list rather than just updates

FIXME: data flow diagram

---

## Fill In the Service

_src/app/to-do.service.ts_
```ts
import { Injectable } from '@angular/core';
import { BehaviorSubject } from 'rxjs/BehaviorSubject';

@Injectable()
export class ToDoService {

  changes: BehaviorSubject<string[]> = new BehaviorSubject([]);
  items: string[] = [];

  constructor() { }

  getChanges() {
    return this.changes;
  }

  addItem(item: string) {
    this.items.push(item);
    this.changes.next(this.items);
  }
}
```

---

## Interlude: What's a Behavior Subject?

- Modern JavaScript relies heavily on the *observer/observable* pattern
  - The observable notifies observers when things change
  - The observer takes action whenever the things they're observing change
- `BehaviorSubject` is an observable with an initial state
- Again, specify type of values using generics
  - `changes` will repeatedly serve a list of strings
- But `BehaviorSubject` doesn't actually store state
- So use a plain old list of strings called `items` to do that

---

## Refactor the Display

_src/app/to-do-list/to-do-list.component.ts_
```ts
export class ToDoListComponent implements OnInit {

  @Input() thingsToDo: string[];

  constructor(private toDoService: ToDoService) { }

  ngOnInit() {
    this.toDoService.getChanges().subscribe((newItems) => {
      this.thingsToDo = newItems.slice();
    });
  }
}
```

- Use `Array.slice` to copy the list of changes each time it arrives
  - Otherwise this component would be sharing state with the service

---

## Interlude: Object Lifecycles

- Q: why set up the subscription in `ngOnInit`?
- A: because we don't control the order in which objects are initialized
- Angular calls `ngOnInit` after everything has been constructed
  but before anything is used
- See Angular's [Lifecycle Hooks](https://angular.io/docs/ts/latest/guide/lifecycle-hooks.html) documentation for details

![Angular Object Lifecycle](content/images/hooks-in-sequence-resized.png)

---

## Refactor the App

_src/app/app.component.ts_
```ts
export class AppComponent {

  title = 'To Do';

  constructor(private toDoService: ToDoService) { }

  onNewItem(item: string) {
    this.toDoService.addItem(item);
  }
}
```

---

## What Reactive Really Means

- This is a lot of work for an application this size
- But absolutely necessary in larger applications
- Main application no longer needs to know who's doing what with the to-do list
- Could add a counter showing number of things to do by:
  1. Creating a new component
  1. Injecting the `ToDoService` into it
  1. Having its HTML display the count
  1. Including its tag in the main page
- More importantly, components are now testable in isolation
  - Inject something else into `ToDoListComponent` to test its behavior

---

## Question

What is the correct way to inject a service into a class?

```ts
1.  class MyComponent {
      constructor(Http) {
        this.http = new Http();
      }
    }

2.  class MyComponent {
      private http: Http;
    }

3.  class MyComponent {
      constructor(http: Http) {
      }
    }

4.  class MyComponent {
      private http: Http = new Http();
    }
```

+++

Correct answer is 3.

4: While it is possible to instantiate classes manually, (and in some
simple, stateless services you may actually get the behaviour you're
expecting), manually instantiated classes lose the benefit of
Angular's DI (their dependencies are no longer able to be dependency
injected) and they require you to manually construct and manage a
dependency tree yourself. Additionally,you're overriding the default
singleton nature of providers in Angular which may lead to unexpected
behaviour.

1: Similar to 4 above with the caveat that `Http` will not be passed
into the constructor to begin with. Providers may only be injected via
a typed constructor parameter (or `@Inject` token).

2: It's possible that when students learn that dependencies are
injected into a class constructor based on its type, they may expect
this type reflection to also apply to class members.

---

## Question

Which of the below snippets would *not* assign a service instance to a
class member (make it available on `this`)?

```ts
1.  class MyComponent {
      constructor(http: Http) {
      }
    }

2.  class MyComponent {
      constructor(private http: Http) {
      }
    }

3.  class MyComponent {
      constructor(public http: Http) {
      }
    }

4.  class MyComponent {
      private http: Http;
      constructor(http: Http) {
        this.http = http;
      }
    }
```

+++

Correct answer is 1.

1: While an instantiated `Http` service will be available in the
constructor, it has not actually been assigned to the class instance
and so is now only available inside of the constructor.

2, 3: The `private` and `public` keywords in typescript will
implicitly assign constructor arguments to the class instance.

4: If you do not specify `private` or `public`, you are still able to
manually assign a provider instance to a class property.

---

## Question

Injecting a service into a class accomplishes which of the following?

1. A new instance of the service is constructed which is then made
   available to the class.

2. A new instance of the service is constructed only if it has not
   been injected before, otherwise an existing instance is reused. The
   instance of the service is then made available to the class.

3. An existing instance of the service is made available to the class
   only if it has already been registered in the `providers` array.

+++

Correct answer is 3.

1, 2: Services can only be injected once they've been explicitly
registered inside of a `providers` array. Angular's DI does not
implicitly construct classes on request.

---

## Question

When generating a service called `MyService` using Angular CLI, what
must be done manually before the service can be used?

1. Import the `MyServiceModule` into the `AppModule`

2. Add `MyService` into the `providers` array

3. Import the `MyServiceModule` into the `AppModule` and add
   `MyService` into the `providers` array

+++

Correct answer is 2.

1, 3: Angular CLI will only generate a service and service test file,
no corresponding module is created. This may be confused in the case
where we're required to import the `HttpModule` in order to use it.
